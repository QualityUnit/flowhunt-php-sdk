<?php
/**
 * FlowsApi
 * PHP version 8.1
 *
 * @category Class
 * @package  FlowHunt
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * FlowHunt
 *
 * FlowHunt API
 *
 * The version of the OpenAPI document: 2.0.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.14.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace FlowHunt\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use FlowHunt\ApiException;
use FlowHunt\Configuration;
use FlowHunt\FormDataProcessor;
use FlowHunt\HeaderSelector;
use FlowHunt\ObjectSerializer;

/**
 * FlowsApi Class Doc Comment
 *
 * @category Class
 * @package  FlowHunt
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class FlowsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'createChatbotSession' => [
            'application/json',
        ],
        'createFlow' => [
            'application/json',
        ],
        'createFlowCategory' => [
            'application/json',
        ],
        'createFlowCron' => [
            'application/json',
        ],
        'createFlowSession' => [
            'application/json',
        ],
        'createMessageFeedback' => [
            'application/json',
        ],
        'deleteAttachment' => [
            'application/json',
        ],
        'deleteFlow' => [
            'application/json',
        ],
        'deleteFlowCategory' => [
            'application/json',
        ],
        'deleteFlowCron' => [
            'application/json',
        ],
        'executeFlowCron' => [
            'application/json',
        ],
        'generateCommitMessage' => [
            'application/json',
        ],
        'get' => [
            'application/json',
        ],
        'getAllComponents' => [
            'application/json',
        ],
        'getAttachments' => [
            'application/json',
        ],
        'getFlowVersions' => [
            'application/json',
        ],
        'getInvokedFlowResults' => [
            'application/json',
        ],
        'getPublicFlow' => [
            'application/json',
        ],
        'getTriggerTypes' => [
            'application/json',
        ],
        'invokeFlow' => [
            'application/json',
        ],
        'invokeFlowResponse' => [
            'application/json',
        ],
        'invokeFlowSingleton' => [
            'application/json',
        ],
        'pollFlowResponse' => [
            'application/json',
        ],
        'publishFlow' => [
            'application/json',
        ],
        'restoreFlowVersion' => [
            'application/json',
        ],
        'search' => [
            'application/json',
        ],
        'searchAll' => [
            'application/json',
        ],
        'searchFlowCategories' => [
            'application/json',
        ],
        'searchFlowCrons' => [
            'application/json',
        ],
        'updateFlow' => [
            'application/json',
        ],
        'updateFlowCategory' => [
            'application/json',
        ],
        'updateFlowCron' => [
            'application/json',
        ],
        'uploadAttachments' => [
            'multipart/form-data',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createChatbotSession
     *
     * Create Chatbot Session
     *
     * @param  string $workspace_id workspace_id (required)
     * @param  \FlowHunt\Model\FlowSessionCreateRequest $flow_session_create_request flow_session_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createChatbotSession'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\FlowSessionResponse|\FlowHunt\Model\HTTPValidationError
     */
    public function createChatbotSession($workspace_id, $flow_session_create_request, string $contentType = self::contentTypes['createChatbotSession'][0])
    {
        list($response) = $this->createChatbotSessionWithHttpInfo($workspace_id, $flow_session_create_request, $contentType);
        return $response;
    }

    /**
     * Operation createChatbotSessionWithHttpInfo
     *
     * Create Chatbot Session
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowSessionCreateRequest $flow_session_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createChatbotSession'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\FlowSessionResponse|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function createChatbotSessionWithHttpInfo($workspace_id, $flow_session_create_request, string $contentType = self::contentTypes['createChatbotSession'][0])
    {
        $request = $this->createChatbotSessionRequest($workspace_id, $flow_session_create_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\FlowSessionResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\FlowSessionResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\FlowSessionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createChatbotSessionAsync
     *
     * Create Chatbot Session
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowSessionCreateRequest $flow_session_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createChatbotSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createChatbotSessionAsync($workspace_id, $flow_session_create_request, string $contentType = self::contentTypes['createChatbotSession'][0])
    {
        return $this->createChatbotSessionAsyncWithHttpInfo($workspace_id, $flow_session_create_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createChatbotSessionAsyncWithHttpInfo
     *
     * Create Chatbot Session
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowSessionCreateRequest $flow_session_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createChatbotSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createChatbotSessionAsyncWithHttpInfo($workspace_id, $flow_session_create_request, string $contentType = self::contentTypes['createChatbotSession'][0])
    {
        $returnType = '\FlowHunt\Model\FlowSessionResponse';
        $request = $this->createChatbotSessionRequest($workspace_id, $flow_session_create_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createChatbotSession'
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowSessionCreateRequest $flow_session_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createChatbotSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createChatbotSessionRequest($workspace_id, $flow_session_create_request, string $contentType = self::contentTypes['createChatbotSession'][0])
    {

        // verify the required parameter 'workspace_id' is set
        if ($workspace_id === null || (is_array($workspace_id) && count($workspace_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workspace_id when calling createChatbotSession'
            );
        }

        // verify the required parameter 'flow_session_create_request' is set
        if ($flow_session_create_request === null || (is_array($flow_session_create_request) && count($flow_session_create_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_session_create_request when calling createChatbotSession'
            );
        }


        $resourcePath = '/v2/flows/sessions/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $workspace_id,
            'workspace_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($flow_session_create_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($flow_session_create_request));
            } else {
                $httpBody = $flow_session_create_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createFlow
     *
     * Create Flow
     *
     * @param  string $workspace_id workspace_id (required)
     * @param  \FlowHunt\Model\FlowCreate $flow_create flow_create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFlow'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\FlowDetailResponse|\FlowHunt\Model\HTTPValidationError
     */
    public function createFlow($workspace_id, $flow_create, string $contentType = self::contentTypes['createFlow'][0])
    {
        list($response) = $this->createFlowWithHttpInfo($workspace_id, $flow_create, $contentType);
        return $response;
    }

    /**
     * Operation createFlowWithHttpInfo
     *
     * Create Flow
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCreate $flow_create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFlow'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\FlowDetailResponse|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function createFlowWithHttpInfo($workspace_id, $flow_create, string $contentType = self::contentTypes['createFlow'][0])
    {
        $request = $this->createFlowRequest($workspace_id, $flow_create, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\FlowDetailResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\FlowDetailResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\FlowDetailResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createFlowAsync
     *
     * Create Flow
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCreate $flow_create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFlow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFlowAsync($workspace_id, $flow_create, string $contentType = self::contentTypes['createFlow'][0])
    {
        return $this->createFlowAsyncWithHttpInfo($workspace_id, $flow_create, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createFlowAsyncWithHttpInfo
     *
     * Create Flow
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCreate $flow_create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFlow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFlowAsyncWithHttpInfo($workspace_id, $flow_create, string $contentType = self::contentTypes['createFlow'][0])
    {
        $returnType = '\FlowHunt\Model\FlowDetailResponse';
        $request = $this->createFlowRequest($workspace_id, $flow_create, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createFlow'
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCreate $flow_create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFlow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createFlowRequest($workspace_id, $flow_create, string $contentType = self::contentTypes['createFlow'][0])
    {

        // verify the required parameter 'workspace_id' is set
        if ($workspace_id === null || (is_array($workspace_id) && count($workspace_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workspace_id when calling createFlow'
            );
        }

        // verify the required parameter 'flow_create' is set
        if ($flow_create === null || (is_array($flow_create) && count($flow_create) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_create when calling createFlow'
            );
        }


        $resourcePath = '/v2/flows/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $workspace_id,
            'workspace_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($flow_create)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($flow_create));
            } else {
                $httpBody = $flow_create;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Api-Key');
        if ($apiKey !== null) {
            $headers['Api-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createFlowCategory
     *
     * Create Flow Category
     *
     * @param  string $workspace_id workspace_id (required)
     * @param  \FlowHunt\Model\FlowCategoryCreateRequest $flow_category_create_request flow_category_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFlowCategory'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\FlowCategoryResponse|\FlowHunt\Model\HTTPValidationError
     */
    public function createFlowCategory($workspace_id, $flow_category_create_request, string $contentType = self::contentTypes['createFlowCategory'][0])
    {
        list($response) = $this->createFlowCategoryWithHttpInfo($workspace_id, $flow_category_create_request, $contentType);
        return $response;
    }

    /**
     * Operation createFlowCategoryWithHttpInfo
     *
     * Create Flow Category
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCategoryCreateRequest $flow_category_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFlowCategory'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\FlowCategoryResponse|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function createFlowCategoryWithHttpInfo($workspace_id, $flow_category_create_request, string $contentType = self::contentTypes['createFlowCategory'][0])
    {
        $request = $this->createFlowCategoryRequest($workspace_id, $flow_category_create_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\FlowCategoryResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\FlowCategoryResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\FlowCategoryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createFlowCategoryAsync
     *
     * Create Flow Category
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCategoryCreateRequest $flow_category_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFlowCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFlowCategoryAsync($workspace_id, $flow_category_create_request, string $contentType = self::contentTypes['createFlowCategory'][0])
    {
        return $this->createFlowCategoryAsyncWithHttpInfo($workspace_id, $flow_category_create_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createFlowCategoryAsyncWithHttpInfo
     *
     * Create Flow Category
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCategoryCreateRequest $flow_category_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFlowCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFlowCategoryAsyncWithHttpInfo($workspace_id, $flow_category_create_request, string $contentType = self::contentTypes['createFlowCategory'][0])
    {
        $returnType = '\FlowHunt\Model\FlowCategoryResponse';
        $request = $this->createFlowCategoryRequest($workspace_id, $flow_category_create_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createFlowCategory'
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCategoryCreateRequest $flow_category_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFlowCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createFlowCategoryRequest($workspace_id, $flow_category_create_request, string $contentType = self::contentTypes['createFlowCategory'][0])
    {

        // verify the required parameter 'workspace_id' is set
        if ($workspace_id === null || (is_array($workspace_id) && count($workspace_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workspace_id when calling createFlowCategory'
            );
        }

        // verify the required parameter 'flow_category_create_request' is set
        if ($flow_category_create_request === null || (is_array($flow_category_create_request) && count($flow_category_create_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_category_create_request when calling createFlowCategory'
            );
        }


        $resourcePath = '/v2/flows/categories/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $workspace_id,
            'workspace_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($flow_category_create_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($flow_category_create_request));
            } else {
                $httpBody = $flow_category_create_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Api-Key');
        if ($apiKey !== null) {
            $headers['Api-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createFlowCron
     *
     * Create Flow Cron
     *
     * @param  string $workspace_id workspace_id (required)
     * @param  \FlowHunt\Model\FlowCronCreateRequest $flow_cron_create_request flow_cron_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFlowCron'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\FlowCronResponse|\FlowHunt\Model\HTTPValidationError
     */
    public function createFlowCron($workspace_id, $flow_cron_create_request, string $contentType = self::contentTypes['createFlowCron'][0])
    {
        list($response) = $this->createFlowCronWithHttpInfo($workspace_id, $flow_cron_create_request, $contentType);
        return $response;
    }

    /**
     * Operation createFlowCronWithHttpInfo
     *
     * Create Flow Cron
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCronCreateRequest $flow_cron_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFlowCron'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\FlowCronResponse|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function createFlowCronWithHttpInfo($workspace_id, $flow_cron_create_request, string $contentType = self::contentTypes['createFlowCron'][0])
    {
        $request = $this->createFlowCronRequest($workspace_id, $flow_cron_create_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\FlowCronResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\FlowCronResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\FlowCronResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createFlowCronAsync
     *
     * Create Flow Cron
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCronCreateRequest $flow_cron_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFlowCron'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFlowCronAsync($workspace_id, $flow_cron_create_request, string $contentType = self::contentTypes['createFlowCron'][0])
    {
        return $this->createFlowCronAsyncWithHttpInfo($workspace_id, $flow_cron_create_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createFlowCronAsyncWithHttpInfo
     *
     * Create Flow Cron
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCronCreateRequest $flow_cron_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFlowCron'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFlowCronAsyncWithHttpInfo($workspace_id, $flow_cron_create_request, string $contentType = self::contentTypes['createFlowCron'][0])
    {
        $returnType = '\FlowHunt\Model\FlowCronResponse';
        $request = $this->createFlowCronRequest($workspace_id, $flow_cron_create_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createFlowCron'
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCronCreateRequest $flow_cron_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFlowCron'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createFlowCronRequest($workspace_id, $flow_cron_create_request, string $contentType = self::contentTypes['createFlowCron'][0])
    {

        // verify the required parameter 'workspace_id' is set
        if ($workspace_id === null || (is_array($workspace_id) && count($workspace_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workspace_id when calling createFlowCron'
            );
        }

        // verify the required parameter 'flow_cron_create_request' is set
        if ($flow_cron_create_request === null || (is_array($flow_cron_create_request) && count($flow_cron_create_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_cron_create_request when calling createFlowCron'
            );
        }


        $resourcePath = '/v2/flows/crons/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $workspace_id,
            'workspace_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($flow_cron_create_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($flow_cron_create_request));
            } else {
                $httpBody = $flow_cron_create_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Api-Key');
        if ($apiKey !== null) {
            $headers['Api-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createFlowSession
     *
     * Create Flow Session
     *
     * @param  string $workspace_id workspace_id (required)
     * @param  \FlowHunt\Model\FlowSessionCreateFromFlowRequest $flow_session_create_from_flow_request flow_session_create_from_flow_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFlowSession'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\FlowSessionResponse|\FlowHunt\Model\HTTPValidationError
     */
    public function createFlowSession($workspace_id, $flow_session_create_from_flow_request, string $contentType = self::contentTypes['createFlowSession'][0])
    {
        list($response) = $this->createFlowSessionWithHttpInfo($workspace_id, $flow_session_create_from_flow_request, $contentType);
        return $response;
    }

    /**
     * Operation createFlowSessionWithHttpInfo
     *
     * Create Flow Session
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowSessionCreateFromFlowRequest $flow_session_create_from_flow_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFlowSession'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\FlowSessionResponse|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function createFlowSessionWithHttpInfo($workspace_id, $flow_session_create_from_flow_request, string $contentType = self::contentTypes['createFlowSession'][0])
    {
        $request = $this->createFlowSessionRequest($workspace_id, $flow_session_create_from_flow_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\FlowSessionResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\FlowSessionResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\FlowSessionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createFlowSessionAsync
     *
     * Create Flow Session
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowSessionCreateFromFlowRequest $flow_session_create_from_flow_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFlowSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFlowSessionAsync($workspace_id, $flow_session_create_from_flow_request, string $contentType = self::contentTypes['createFlowSession'][0])
    {
        return $this->createFlowSessionAsyncWithHttpInfo($workspace_id, $flow_session_create_from_flow_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createFlowSessionAsyncWithHttpInfo
     *
     * Create Flow Session
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowSessionCreateFromFlowRequest $flow_session_create_from_flow_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFlowSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFlowSessionAsyncWithHttpInfo($workspace_id, $flow_session_create_from_flow_request, string $contentType = self::contentTypes['createFlowSession'][0])
    {
        $returnType = '\FlowHunt\Model\FlowSessionResponse';
        $request = $this->createFlowSessionRequest($workspace_id, $flow_session_create_from_flow_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createFlowSession'
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowSessionCreateFromFlowRequest $flow_session_create_from_flow_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFlowSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createFlowSessionRequest($workspace_id, $flow_session_create_from_flow_request, string $contentType = self::contentTypes['createFlowSession'][0])
    {

        // verify the required parameter 'workspace_id' is set
        if ($workspace_id === null || (is_array($workspace_id) && count($workspace_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workspace_id when calling createFlowSession'
            );
        }

        // verify the required parameter 'flow_session_create_from_flow_request' is set
        if ($flow_session_create_from_flow_request === null || (is_array($flow_session_create_from_flow_request) && count($flow_session_create_from_flow_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_session_create_from_flow_request when calling createFlowSession'
            );
        }


        $resourcePath = '/v2/flows/sessions/from_flow/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $workspace_id,
            'workspace_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($flow_session_create_from_flow_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($flow_session_create_from_flow_request));
            } else {
                $httpBody = $flow_session_create_from_flow_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Api-Key');
        if ($apiKey !== null) {
            $headers['Api-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createMessageFeedback
     *
     * Create Message Feedback
     *
     * @param  string $session_id session_id (required)
     * @param  \FlowHunt\Model\FlowMessageFeedbackRequest $flow_message_feedback_request flow_message_feedback_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMessageFeedback'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\FlowMessageFeedbackResponse|\FlowHunt\Model\HTTPValidationError
     */
    public function createMessageFeedback($session_id, $flow_message_feedback_request, string $contentType = self::contentTypes['createMessageFeedback'][0])
    {
        list($response) = $this->createMessageFeedbackWithHttpInfo($session_id, $flow_message_feedback_request, $contentType);
        return $response;
    }

    /**
     * Operation createMessageFeedbackWithHttpInfo
     *
     * Create Message Feedback
     *
     * @param  string $session_id (required)
     * @param  \FlowHunt\Model\FlowMessageFeedbackRequest $flow_message_feedback_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMessageFeedback'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\FlowMessageFeedbackResponse|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function createMessageFeedbackWithHttpInfo($session_id, $flow_message_feedback_request, string $contentType = self::contentTypes['createMessageFeedback'][0])
    {
        $request = $this->createMessageFeedbackRequest($session_id, $flow_message_feedback_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\FlowMessageFeedbackResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\FlowMessageFeedbackResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\FlowMessageFeedbackResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createMessageFeedbackAsync
     *
     * Create Message Feedback
     *
     * @param  string $session_id (required)
     * @param  \FlowHunt\Model\FlowMessageFeedbackRequest $flow_message_feedback_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMessageFeedback'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createMessageFeedbackAsync($session_id, $flow_message_feedback_request, string $contentType = self::contentTypes['createMessageFeedback'][0])
    {
        return $this->createMessageFeedbackAsyncWithHttpInfo($session_id, $flow_message_feedback_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createMessageFeedbackAsyncWithHttpInfo
     *
     * Create Message Feedback
     *
     * @param  string $session_id (required)
     * @param  \FlowHunt\Model\FlowMessageFeedbackRequest $flow_message_feedback_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMessageFeedback'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createMessageFeedbackAsyncWithHttpInfo($session_id, $flow_message_feedback_request, string $contentType = self::contentTypes['createMessageFeedback'][0])
    {
        $returnType = '\FlowHunt\Model\FlowMessageFeedbackResponse';
        $request = $this->createMessageFeedbackRequest($session_id, $flow_message_feedback_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createMessageFeedback'
     *
     * @param  string $session_id (required)
     * @param  \FlowHunt\Model\FlowMessageFeedbackRequest $flow_message_feedback_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMessageFeedback'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createMessageFeedbackRequest($session_id, $flow_message_feedback_request, string $contentType = self::contentTypes['createMessageFeedback'][0])
    {

        // verify the required parameter 'session_id' is set
        if ($session_id === null || (is_array($session_id) && count($session_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $session_id when calling createMessageFeedback'
            );
        }

        // verify the required parameter 'flow_message_feedback_request' is set
        if ($flow_message_feedback_request === null || (is_array($flow_message_feedback_request) && count($flow_message_feedback_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_message_feedback_request when calling createMessageFeedback'
            );
        }


        $resourcePath = '/v2/flows/sessions/{session_id}/feedback';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($session_id !== null) {
            $resourcePath = str_replace(
                '{' . 'session_id' . '}',
                ObjectSerializer::toPathValue($session_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($flow_message_feedback_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($flow_message_feedback_request));
            } else {
                $httpBody = $flow_message_feedback_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAttachment
     *
     * Delete Attachment
     *
     * @param  string $session_id session_id (required)
     * @param  string $file_id file_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAttachment'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\Completed|\FlowHunt\Model\HTTPValidationError
     */
    public function deleteAttachment($session_id, $file_id, string $contentType = self::contentTypes['deleteAttachment'][0])
    {
        list($response) = $this->deleteAttachmentWithHttpInfo($session_id, $file_id, $contentType);
        return $response;
    }

    /**
     * Operation deleteAttachmentWithHttpInfo
     *
     * Delete Attachment
     *
     * @param  string $session_id (required)
     * @param  string $file_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAttachment'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\Completed|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAttachmentWithHttpInfo($session_id, $file_id, string $contentType = self::contentTypes['deleteAttachment'][0])
    {
        $request = $this->deleteAttachmentRequest($session_id, $file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\Completed',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\Completed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\Completed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteAttachmentAsync
     *
     * Delete Attachment
     *
     * @param  string $session_id (required)
     * @param  string $file_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAttachmentAsync($session_id, $file_id, string $contentType = self::contentTypes['deleteAttachment'][0])
    {
        return $this->deleteAttachmentAsyncWithHttpInfo($session_id, $file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAttachmentAsyncWithHttpInfo
     *
     * Delete Attachment
     *
     * @param  string $session_id (required)
     * @param  string $file_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAttachmentAsyncWithHttpInfo($session_id, $file_id, string $contentType = self::contentTypes['deleteAttachment'][0])
    {
        $returnType = '\FlowHunt\Model\Completed';
        $request = $this->deleteAttachmentRequest($session_id, $file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAttachment'
     *
     * @param  string $session_id (required)
     * @param  string $file_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAttachmentRequest($session_id, $file_id, string $contentType = self::contentTypes['deleteAttachment'][0])
    {

        // verify the required parameter 'session_id' is set
        if ($session_id === null || (is_array($session_id) && count($session_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $session_id when calling deleteAttachment'
            );
        }

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling deleteAttachment'
            );
        }


        $resourcePath = '/v2/flows/sessions/{session_id}/attachments/{file_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($session_id !== null) {
            $resourcePath = str_replace(
                '{' . 'session_id' . '}',
                ObjectSerializer::toPathValue($session_id),
                $resourcePath
            );
        }
        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'file_id' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFlow
     *
     * Delete Flow
     *
     * @param  string $flow_id flow_id (required)
     * @param  string $workspace_id workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFlow'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\Completed|\FlowHunt\Model\HTTPValidationError
     */
    public function deleteFlow($flow_id, $workspace_id, string $contentType = self::contentTypes['deleteFlow'][0])
    {
        list($response) = $this->deleteFlowWithHttpInfo($flow_id, $workspace_id, $contentType);
        return $response;
    }

    /**
     * Operation deleteFlowWithHttpInfo
     *
     * Delete Flow
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFlow'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\Completed|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFlowWithHttpInfo($flow_id, $workspace_id, string $contentType = self::contentTypes['deleteFlow'][0])
    {
        $request = $this->deleteFlowRequest($flow_id, $workspace_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\Completed',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\Completed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\Completed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteFlowAsync
     *
     * Delete Flow
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFlow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFlowAsync($flow_id, $workspace_id, string $contentType = self::contentTypes['deleteFlow'][0])
    {
        return $this->deleteFlowAsyncWithHttpInfo($flow_id, $workspace_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFlowAsyncWithHttpInfo
     *
     * Delete Flow
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFlow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFlowAsyncWithHttpInfo($flow_id, $workspace_id, string $contentType = self::contentTypes['deleteFlow'][0])
    {
        $returnType = '\FlowHunt\Model\Completed';
        $request = $this->deleteFlowRequest($flow_id, $workspace_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFlow'
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFlow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteFlowRequest($flow_id, $workspace_id, string $contentType = self::contentTypes['deleteFlow'][0])
    {

        // verify the required parameter 'flow_id' is set
        if ($flow_id === null || (is_array($flow_id) && count($flow_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_id when calling deleteFlow'
            );
        }

        // verify the required parameter 'workspace_id' is set
        if ($workspace_id === null || (is_array($workspace_id) && count($workspace_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workspace_id when calling deleteFlow'
            );
        }


        $resourcePath = '/v2/flows/{flow_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $workspace_id,
            'workspace_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($flow_id !== null) {
            $resourcePath = str_replace(
                '{' . 'flow_id' . '}',
                ObjectSerializer::toPathValue($flow_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Api-Key');
        if ($apiKey !== null) {
            $headers['Api-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFlowCategory
     *
     * Delete Flow Category
     *
     * @param  string $cat_id cat_id (required)
     * @param  string $workspace_id workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFlowCategory'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\Completed|\FlowHunt\Model\HTTPValidationError
     */
    public function deleteFlowCategory($cat_id, $workspace_id, string $contentType = self::contentTypes['deleteFlowCategory'][0])
    {
        list($response) = $this->deleteFlowCategoryWithHttpInfo($cat_id, $workspace_id, $contentType);
        return $response;
    }

    /**
     * Operation deleteFlowCategoryWithHttpInfo
     *
     * Delete Flow Category
     *
     * @param  string $cat_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFlowCategory'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\Completed|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFlowCategoryWithHttpInfo($cat_id, $workspace_id, string $contentType = self::contentTypes['deleteFlowCategory'][0])
    {
        $request = $this->deleteFlowCategoryRequest($cat_id, $workspace_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\Completed',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\Completed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\Completed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteFlowCategoryAsync
     *
     * Delete Flow Category
     *
     * @param  string $cat_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFlowCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFlowCategoryAsync($cat_id, $workspace_id, string $contentType = self::contentTypes['deleteFlowCategory'][0])
    {
        return $this->deleteFlowCategoryAsyncWithHttpInfo($cat_id, $workspace_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFlowCategoryAsyncWithHttpInfo
     *
     * Delete Flow Category
     *
     * @param  string $cat_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFlowCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFlowCategoryAsyncWithHttpInfo($cat_id, $workspace_id, string $contentType = self::contentTypes['deleteFlowCategory'][0])
    {
        $returnType = '\FlowHunt\Model\Completed';
        $request = $this->deleteFlowCategoryRequest($cat_id, $workspace_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFlowCategory'
     *
     * @param  string $cat_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFlowCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteFlowCategoryRequest($cat_id, $workspace_id, string $contentType = self::contentTypes['deleteFlowCategory'][0])
    {

        // verify the required parameter 'cat_id' is set
        if ($cat_id === null || (is_array($cat_id) && count($cat_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cat_id when calling deleteFlowCategory'
            );
        }

        // verify the required parameter 'workspace_id' is set
        if ($workspace_id === null || (is_array($workspace_id) && count($workspace_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workspace_id when calling deleteFlowCategory'
            );
        }


        $resourcePath = '/v2/flows/categories/{cat_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $workspace_id,
            'workspace_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($cat_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cat_id' . '}',
                ObjectSerializer::toPathValue($cat_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Api-Key');
        if ($apiKey !== null) {
            $headers['Api-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFlowCron
     *
     * Delete Flow Cron
     *
     * @param  string $flow_id flow_id (required)
     * @param  string $cron_id cron_id (required)
     * @param  string $workspace_id workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFlowCron'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\Completed|\FlowHunt\Model\HTTPValidationError
     */
    public function deleteFlowCron($flow_id, $cron_id, $workspace_id, string $contentType = self::contentTypes['deleteFlowCron'][0])
    {
        list($response) = $this->deleteFlowCronWithHttpInfo($flow_id, $cron_id, $workspace_id, $contentType);
        return $response;
    }

    /**
     * Operation deleteFlowCronWithHttpInfo
     *
     * Delete Flow Cron
     *
     * @param  string $flow_id (required)
     * @param  string $cron_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFlowCron'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\Completed|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFlowCronWithHttpInfo($flow_id, $cron_id, $workspace_id, string $contentType = self::contentTypes['deleteFlowCron'][0])
    {
        $request = $this->deleteFlowCronRequest($flow_id, $cron_id, $workspace_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\Completed',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\Completed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\Completed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteFlowCronAsync
     *
     * Delete Flow Cron
     *
     * @param  string $flow_id (required)
     * @param  string $cron_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFlowCron'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFlowCronAsync($flow_id, $cron_id, $workspace_id, string $contentType = self::contentTypes['deleteFlowCron'][0])
    {
        return $this->deleteFlowCronAsyncWithHttpInfo($flow_id, $cron_id, $workspace_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFlowCronAsyncWithHttpInfo
     *
     * Delete Flow Cron
     *
     * @param  string $flow_id (required)
     * @param  string $cron_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFlowCron'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFlowCronAsyncWithHttpInfo($flow_id, $cron_id, $workspace_id, string $contentType = self::contentTypes['deleteFlowCron'][0])
    {
        $returnType = '\FlowHunt\Model\Completed';
        $request = $this->deleteFlowCronRequest($flow_id, $cron_id, $workspace_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFlowCron'
     *
     * @param  string $flow_id (required)
     * @param  string $cron_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFlowCron'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteFlowCronRequest($flow_id, $cron_id, $workspace_id, string $contentType = self::contentTypes['deleteFlowCron'][0])
    {

        // verify the required parameter 'flow_id' is set
        if ($flow_id === null || (is_array($flow_id) && count($flow_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_id when calling deleteFlowCron'
            );
        }

        // verify the required parameter 'cron_id' is set
        if ($cron_id === null || (is_array($cron_id) && count($cron_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cron_id when calling deleteFlowCron'
            );
        }

        // verify the required parameter 'workspace_id' is set
        if ($workspace_id === null || (is_array($workspace_id) && count($workspace_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workspace_id when calling deleteFlowCron'
            );
        }


        $resourcePath = '/v2/flows/crons/{flow_id}/{cron_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $workspace_id,
            'workspace_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($flow_id !== null) {
            $resourcePath = str_replace(
                '{' . 'flow_id' . '}',
                ObjectSerializer::toPathValue($flow_id),
                $resourcePath
            );
        }
        // path params
        if ($cron_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cron_id' . '}',
                ObjectSerializer::toPathValue($cron_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Api-Key');
        if ($apiKey !== null) {
            $headers['Api-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation executeFlowCron
     *
     * Execute Flow Cron
     *
     * @param  string $cron_id cron_id (required)
     * @param  string $flow_id flow_id (required)
     * @param  string $workspace_id workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['executeFlowCron'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\TaskResponse|\FlowHunt\Model\HTTPValidationError
     */
    public function executeFlowCron($cron_id, $flow_id, $workspace_id, string $contentType = self::contentTypes['executeFlowCron'][0])
    {
        list($response) = $this->executeFlowCronWithHttpInfo($cron_id, $flow_id, $workspace_id, $contentType);
        return $response;
    }

    /**
     * Operation executeFlowCronWithHttpInfo
     *
     * Execute Flow Cron
     *
     * @param  string $cron_id (required)
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['executeFlowCron'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\TaskResponse|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function executeFlowCronWithHttpInfo($cron_id, $flow_id, $workspace_id, string $contentType = self::contentTypes['executeFlowCron'][0])
    {
        $request = $this->executeFlowCronRequest($cron_id, $flow_id, $workspace_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\TaskResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\TaskResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\TaskResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation executeFlowCronAsync
     *
     * Execute Flow Cron
     *
     * @param  string $cron_id (required)
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['executeFlowCron'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function executeFlowCronAsync($cron_id, $flow_id, $workspace_id, string $contentType = self::contentTypes['executeFlowCron'][0])
    {
        return $this->executeFlowCronAsyncWithHttpInfo($cron_id, $flow_id, $workspace_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation executeFlowCronAsyncWithHttpInfo
     *
     * Execute Flow Cron
     *
     * @param  string $cron_id (required)
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['executeFlowCron'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function executeFlowCronAsyncWithHttpInfo($cron_id, $flow_id, $workspace_id, string $contentType = self::contentTypes['executeFlowCron'][0])
    {
        $returnType = '\FlowHunt\Model\TaskResponse';
        $request = $this->executeFlowCronRequest($cron_id, $flow_id, $workspace_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'executeFlowCron'
     *
     * @param  string $cron_id (required)
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['executeFlowCron'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function executeFlowCronRequest($cron_id, $flow_id, $workspace_id, string $contentType = self::contentTypes['executeFlowCron'][0])
    {

        // verify the required parameter 'cron_id' is set
        if ($cron_id === null || (is_array($cron_id) && count($cron_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cron_id when calling executeFlowCron'
            );
        }

        // verify the required parameter 'flow_id' is set
        if ($flow_id === null || (is_array($flow_id) && count($flow_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_id when calling executeFlowCron'
            );
        }

        // verify the required parameter 'workspace_id' is set
        if ($workspace_id === null || (is_array($workspace_id) && count($workspace_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workspace_id when calling executeFlowCron'
            );
        }


        $resourcePath = '/v2/flows/crons/{flow_id}/{cron_id}/execute';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $workspace_id,
            'workspace_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($cron_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cron_id' . '}',
                ObjectSerializer::toPathValue($cron_id),
                $resourcePath
            );
        }
        // path params
        if ($flow_id !== null) {
            $resourcePath = str_replace(
                '{' . 'flow_id' . '}',
                ObjectSerializer::toPathValue($flow_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Api-Key');
        if ($apiKey !== null) {
            $headers['Api-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation generateCommitMessage
     *
     * Generate Commit Message
     *
     * @param  string $flow_id flow_id (required)
     * @param  string $workspace_id workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateCommitMessage'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\FlowCommitResponse|\FlowHunt\Model\HTTPValidationError
     */
    public function generateCommitMessage($flow_id, $workspace_id, string $contentType = self::contentTypes['generateCommitMessage'][0])
    {
        list($response) = $this->generateCommitMessageWithHttpInfo($flow_id, $workspace_id, $contentType);
        return $response;
    }

    /**
     * Operation generateCommitMessageWithHttpInfo
     *
     * Generate Commit Message
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateCommitMessage'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\FlowCommitResponse|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function generateCommitMessageWithHttpInfo($flow_id, $workspace_id, string $contentType = self::contentTypes['generateCommitMessage'][0])
    {
        $request = $this->generateCommitMessageRequest($flow_id, $workspace_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\FlowCommitResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\FlowCommitResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\FlowCommitResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation generateCommitMessageAsync
     *
     * Generate Commit Message
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateCommitMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateCommitMessageAsync($flow_id, $workspace_id, string $contentType = self::contentTypes['generateCommitMessage'][0])
    {
        return $this->generateCommitMessageAsyncWithHttpInfo($flow_id, $workspace_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation generateCommitMessageAsyncWithHttpInfo
     *
     * Generate Commit Message
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateCommitMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateCommitMessageAsyncWithHttpInfo($flow_id, $workspace_id, string $contentType = self::contentTypes['generateCommitMessage'][0])
    {
        $returnType = '\FlowHunt\Model\FlowCommitResponse';
        $request = $this->generateCommitMessageRequest($flow_id, $workspace_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'generateCommitMessage'
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateCommitMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function generateCommitMessageRequest($flow_id, $workspace_id, string $contentType = self::contentTypes['generateCommitMessage'][0])
    {

        // verify the required parameter 'flow_id' is set
        if ($flow_id === null || (is_array($flow_id) && count($flow_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_id when calling generateCommitMessage'
            );
        }

        // verify the required parameter 'workspace_id' is set
        if ($workspace_id === null || (is_array($workspace_id) && count($workspace_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workspace_id when calling generateCommitMessage'
            );
        }


        $resourcePath = '/v2/flows/{flow_id}/generate-commit-msg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $workspace_id,
            'workspace_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($flow_id !== null) {
            $resourcePath = str_replace(
                '{' . 'flow_id' . '}',
                ObjectSerializer::toPathValue($flow_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Api-Key');
        if ($apiKey !== null) {
            $headers['Api-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation get
     *
     * Get
     *
     * @param  string $flow_id flow_id (required)
     * @param  string $workspace_id workspace_id (required)
     * @param  string|null $branch branch (optional, default to 'D')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['get'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\FlowDetailResponse|\FlowHunt\Model\HTTPValidationError
     */
    public function get($flow_id, $workspace_id, $branch = 'D', string $contentType = self::contentTypes['get'][0])
    {
        list($response) = $this->getWithHttpInfo($flow_id, $workspace_id, $branch, $contentType);
        return $response;
    }

    /**
     * Operation getWithHttpInfo
     *
     * Get
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  string|null $branch (optional, default to 'D')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['get'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\FlowDetailResponse|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWithHttpInfo($flow_id, $workspace_id, $branch = 'D', string $contentType = self::contentTypes['get'][0])
    {
        $request = $this->getRequest($flow_id, $workspace_id, $branch, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\FlowDetailResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\FlowDetailResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\FlowDetailResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getAsync
     *
     * Get
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  string|null $branch (optional, default to 'D')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAsync($flow_id, $workspace_id, $branch = 'D', string $contentType = self::contentTypes['get'][0])
    {
        return $this->getAsyncWithHttpInfo($flow_id, $workspace_id, $branch, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAsyncWithHttpInfo
     *
     * Get
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  string|null $branch (optional, default to 'D')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAsyncWithHttpInfo($flow_id, $workspace_id, $branch = 'D', string $contentType = self::contentTypes['get'][0])
    {
        $returnType = '\FlowHunt\Model\FlowDetailResponse';
        $request = $this->getRequest($flow_id, $workspace_id, $branch, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'get'
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  string|null $branch (optional, default to 'D')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRequest($flow_id, $workspace_id, $branch = 'D', string $contentType = self::contentTypes['get'][0])
    {

        // verify the required parameter 'flow_id' is set
        if ($flow_id === null || (is_array($flow_id) && count($flow_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_id when calling get'
            );
        }

        // verify the required parameter 'workspace_id' is set
        if ($workspace_id === null || (is_array($workspace_id) && count($workspace_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workspace_id when calling get'
            );
        }



        $resourcePath = '/v2/flows/{flow_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $workspace_id,
            'workspace_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $branch,
            'branch', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($flow_id !== null) {
            $resourcePath = str_replace(
                '{' . 'flow_id' . '}',
                ObjectSerializer::toPathValue($flow_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Api-Key');
        if ($apiKey !== null) {
            $headers['Api-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllComponents
     *
     * Get All Components
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllComponents'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function getAllComponents(string $contentType = self::contentTypes['getAllComponents'][0])
    {
        list($response) = $this->getAllComponentsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getAllComponentsWithHttpInfo
     *
     * Get All Components
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllComponents'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllComponentsWithHttpInfo(string $contentType = self::contentTypes['getAllComponents'][0])
    {
        $request = $this->getAllComponentsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'mixed',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'mixed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getAllComponentsAsync
     *
     * Get All Components
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllComponents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllComponentsAsync(string $contentType = self::contentTypes['getAllComponents'][0])
    {
        return $this->getAllComponentsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllComponentsAsyncWithHttpInfo
     *
     * Get All Components
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllComponents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllComponentsAsyncWithHttpInfo(string $contentType = self::contentTypes['getAllComponents'][0])
    {
        $returnType = 'mixed';
        $request = $this->getAllComponentsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllComponents'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllComponents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAllComponentsRequest(string $contentType = self::contentTypes['getAllComponents'][0])
    {


        $resourcePath = '/v2/flows/components/all';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Api-Key');
        if ($apiKey !== null) {
            $headers['Api-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAttachments
     *
     * Get Attachments
     *
     * @param  string $session_id session_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAttachments'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\FlowSessionAttachmentResponse[]|\FlowHunt\Model\HTTPValidationError
     */
    public function getAttachments($session_id, string $contentType = self::contentTypes['getAttachments'][0])
    {
        list($response) = $this->getAttachmentsWithHttpInfo($session_id, $contentType);
        return $response;
    }

    /**
     * Operation getAttachmentsWithHttpInfo
     *
     * Get Attachments
     *
     * @param  string $session_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAttachments'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\FlowSessionAttachmentResponse[]|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAttachmentsWithHttpInfo($session_id, string $contentType = self::contentTypes['getAttachments'][0])
    {
        $request = $this->getAttachmentsRequest($session_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\FlowSessionAttachmentResponse[]',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\FlowSessionAttachmentResponse[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\FlowSessionAttachmentResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getAttachmentsAsync
     *
     * Get Attachments
     *
     * @param  string $session_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAttachments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAttachmentsAsync($session_id, string $contentType = self::contentTypes['getAttachments'][0])
    {
        return $this->getAttachmentsAsyncWithHttpInfo($session_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAttachmentsAsyncWithHttpInfo
     *
     * Get Attachments
     *
     * @param  string $session_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAttachments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAttachmentsAsyncWithHttpInfo($session_id, string $contentType = self::contentTypes['getAttachments'][0])
    {
        $returnType = '\FlowHunt\Model\FlowSessionAttachmentResponse[]';
        $request = $this->getAttachmentsRequest($session_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAttachments'
     *
     * @param  string $session_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAttachments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAttachmentsRequest($session_id, string $contentType = self::contentTypes['getAttachments'][0])
    {

        // verify the required parameter 'session_id' is set
        if ($session_id === null || (is_array($session_id) && count($session_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $session_id when calling getAttachments'
            );
        }


        $resourcePath = '/v2/flows/sessions/{session_id}/attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($session_id !== null) {
            $resourcePath = str_replace(
                '{' . 'session_id' . '}',
                ObjectSerializer::toPathValue($session_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFlowVersions
     *
     * Get Flow Versions
     *
     * @param  string $flow_id flow_id (required)
     * @param  string $workspace_id workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFlowVersions'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\FlowVersionHistoryResponse[]|\FlowHunt\Model\HTTPValidationError
     */
    public function getFlowVersions($flow_id, $workspace_id, string $contentType = self::contentTypes['getFlowVersions'][0])
    {
        list($response) = $this->getFlowVersionsWithHttpInfo($flow_id, $workspace_id, $contentType);
        return $response;
    }

    /**
     * Operation getFlowVersionsWithHttpInfo
     *
     * Get Flow Versions
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFlowVersions'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\FlowVersionHistoryResponse[]|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFlowVersionsWithHttpInfo($flow_id, $workspace_id, string $contentType = self::contentTypes['getFlowVersions'][0])
    {
        $request = $this->getFlowVersionsRequest($flow_id, $workspace_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\FlowVersionHistoryResponse[]',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\FlowVersionHistoryResponse[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\FlowVersionHistoryResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getFlowVersionsAsync
     *
     * Get Flow Versions
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFlowVersions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFlowVersionsAsync($flow_id, $workspace_id, string $contentType = self::contentTypes['getFlowVersions'][0])
    {
        return $this->getFlowVersionsAsyncWithHttpInfo($flow_id, $workspace_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFlowVersionsAsyncWithHttpInfo
     *
     * Get Flow Versions
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFlowVersions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFlowVersionsAsyncWithHttpInfo($flow_id, $workspace_id, string $contentType = self::contentTypes['getFlowVersions'][0])
    {
        $returnType = '\FlowHunt\Model\FlowVersionHistoryResponse[]';
        $request = $this->getFlowVersionsRequest($flow_id, $workspace_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFlowVersions'
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFlowVersions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFlowVersionsRequest($flow_id, $workspace_id, string $contentType = self::contentTypes['getFlowVersions'][0])
    {

        // verify the required parameter 'flow_id' is set
        if ($flow_id === null || (is_array($flow_id) && count($flow_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_id when calling getFlowVersions'
            );
        }

        // verify the required parameter 'workspace_id' is set
        if ($workspace_id === null || (is_array($workspace_id) && count($workspace_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workspace_id when calling getFlowVersions'
            );
        }


        $resourcePath = '/v2/flows/{flow_id}/version_history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $workspace_id,
            'workspace_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($flow_id !== null) {
            $resourcePath = str_replace(
                '{' . 'flow_id' . '}',
                ObjectSerializer::toPathValue($flow_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Api-Key');
        if ($apiKey !== null) {
            $headers['Api-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInvokedFlowResults
     *
     * Get Invoked Flow Results
     *
     * @param  string $flow_id flow_id (required)
     * @param  string $task_id task_id (required)
     * @param  string $workspace_id workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInvokedFlowResults'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\TaskResponse|\FlowHunt\Model\HTTPValidationError
     */
    public function getInvokedFlowResults($flow_id, $task_id, $workspace_id, string $contentType = self::contentTypes['getInvokedFlowResults'][0])
    {
        list($response) = $this->getInvokedFlowResultsWithHttpInfo($flow_id, $task_id, $workspace_id, $contentType);
        return $response;
    }

    /**
     * Operation getInvokedFlowResultsWithHttpInfo
     *
     * Get Invoked Flow Results
     *
     * @param  string $flow_id (required)
     * @param  string $task_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInvokedFlowResults'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\TaskResponse|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvokedFlowResultsWithHttpInfo($flow_id, $task_id, $workspace_id, string $contentType = self::contentTypes['getInvokedFlowResults'][0])
    {
        $request = $this->getInvokedFlowResultsRequest($flow_id, $task_id, $workspace_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\TaskResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\TaskResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\TaskResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getInvokedFlowResultsAsync
     *
     * Get Invoked Flow Results
     *
     * @param  string $flow_id (required)
     * @param  string $task_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInvokedFlowResults'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvokedFlowResultsAsync($flow_id, $task_id, $workspace_id, string $contentType = self::contentTypes['getInvokedFlowResults'][0])
    {
        return $this->getInvokedFlowResultsAsyncWithHttpInfo($flow_id, $task_id, $workspace_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvokedFlowResultsAsyncWithHttpInfo
     *
     * Get Invoked Flow Results
     *
     * @param  string $flow_id (required)
     * @param  string $task_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInvokedFlowResults'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvokedFlowResultsAsyncWithHttpInfo($flow_id, $task_id, $workspace_id, string $contentType = self::contentTypes['getInvokedFlowResults'][0])
    {
        $returnType = '\FlowHunt\Model\TaskResponse';
        $request = $this->getInvokedFlowResultsRequest($flow_id, $task_id, $workspace_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvokedFlowResults'
     *
     * @param  string $flow_id (required)
     * @param  string $task_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInvokedFlowResults'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getInvokedFlowResultsRequest($flow_id, $task_id, $workspace_id, string $contentType = self::contentTypes['getInvokedFlowResults'][0])
    {

        // verify the required parameter 'flow_id' is set
        if ($flow_id === null || (is_array($flow_id) && count($flow_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_id when calling getInvokedFlowResults'
            );
        }

        // verify the required parameter 'task_id' is set
        if ($task_id === null || (is_array($task_id) && count($task_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling getInvokedFlowResults'
            );
        }

        // verify the required parameter 'workspace_id' is set
        if ($workspace_id === null || (is_array($workspace_id) && count($workspace_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workspace_id when calling getInvokedFlowResults'
            );
        }


        $resourcePath = '/v2/flows/{flow_id}/{task_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $workspace_id,
            'workspace_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($flow_id !== null) {
            $resourcePath = str_replace(
                '{' . 'flow_id' . '}',
                ObjectSerializer::toPathValue($flow_id),
                $resourcePath
            );
        }
        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'task_id' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Api-Key');
        if ($apiKey !== null) {
            $headers['Api-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPublicFlow
     *
     * Get Public Flow
     *
     * @param  string $flow_id flow_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPublicFlow'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\FlowDetailResponse|\FlowHunt\Model\HTTPValidationError
     */
    public function getPublicFlow($flow_id, string $contentType = self::contentTypes['getPublicFlow'][0])
    {
        list($response) = $this->getPublicFlowWithHttpInfo($flow_id, $contentType);
        return $response;
    }

    /**
     * Operation getPublicFlowWithHttpInfo
     *
     * Get Public Flow
     *
     * @param  string $flow_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPublicFlow'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\FlowDetailResponse|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPublicFlowWithHttpInfo($flow_id, string $contentType = self::contentTypes['getPublicFlow'][0])
    {
        $request = $this->getPublicFlowRequest($flow_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\FlowDetailResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\FlowDetailResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\FlowDetailResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getPublicFlowAsync
     *
     * Get Public Flow
     *
     * @param  string $flow_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPublicFlow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublicFlowAsync($flow_id, string $contentType = self::contentTypes['getPublicFlow'][0])
    {
        return $this->getPublicFlowAsyncWithHttpInfo($flow_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPublicFlowAsyncWithHttpInfo
     *
     * Get Public Flow
     *
     * @param  string $flow_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPublicFlow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublicFlowAsyncWithHttpInfo($flow_id, string $contentType = self::contentTypes['getPublicFlow'][0])
    {
        $returnType = '\FlowHunt\Model\FlowDetailResponse';
        $request = $this->getPublicFlowRequest($flow_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPublicFlow'
     *
     * @param  string $flow_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPublicFlow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPublicFlowRequest($flow_id, string $contentType = self::contentTypes['getPublicFlow'][0])
    {

        // verify the required parameter 'flow_id' is set
        if ($flow_id === null || (is_array($flow_id) && count($flow_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_id when calling getPublicFlow'
            );
        }


        $resourcePath = '/v2/flows/public/{flow_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($flow_id !== null) {
            $resourcePath = str_replace(
                '{' . 'flow_id' . '}',
                ObjectSerializer::toPathValue($flow_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Api-Key');
        if ($apiKey !== null) {
            $headers['Api-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTriggerTypes
     *
     * Get Trigger Types
     *
     * @param  string $flow_id flow_id (required)
     * @param  string $workspace_id workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTriggerTypes'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\TriggerResponse|\FlowHunt\Model\HTTPValidationError
     */
    public function getTriggerTypes($flow_id, $workspace_id, string $contentType = self::contentTypes['getTriggerTypes'][0])
    {
        list($response) = $this->getTriggerTypesWithHttpInfo($flow_id, $workspace_id, $contentType);
        return $response;
    }

    /**
     * Operation getTriggerTypesWithHttpInfo
     *
     * Get Trigger Types
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTriggerTypes'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\TriggerResponse|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTriggerTypesWithHttpInfo($flow_id, $workspace_id, string $contentType = self::contentTypes['getTriggerTypes'][0])
    {
        $request = $this->getTriggerTypesRequest($flow_id, $workspace_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\TriggerResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\TriggerResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\TriggerResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getTriggerTypesAsync
     *
     * Get Trigger Types
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTriggerTypes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTriggerTypesAsync($flow_id, $workspace_id, string $contentType = self::contentTypes['getTriggerTypes'][0])
    {
        return $this->getTriggerTypesAsyncWithHttpInfo($flow_id, $workspace_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTriggerTypesAsyncWithHttpInfo
     *
     * Get Trigger Types
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTriggerTypes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTriggerTypesAsyncWithHttpInfo($flow_id, $workspace_id, string $contentType = self::contentTypes['getTriggerTypes'][0])
    {
        $returnType = '\FlowHunt\Model\TriggerResponse';
        $request = $this->getTriggerTypesRequest($flow_id, $workspace_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTriggerTypes'
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTriggerTypes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTriggerTypesRequest($flow_id, $workspace_id, string $contentType = self::contentTypes['getTriggerTypes'][0])
    {

        // verify the required parameter 'flow_id' is set
        if ($flow_id === null || (is_array($flow_id) && count($flow_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_id when calling getTriggerTypes'
            );
        }

        // verify the required parameter 'workspace_id' is set
        if ($workspace_id === null || (is_array($workspace_id) && count($workspace_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workspace_id when calling getTriggerTypes'
            );
        }


        $resourcePath = '/v2/flows/{flow_id}/triggers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $workspace_id,
            'workspace_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($flow_id !== null) {
            $resourcePath = str_replace(
                '{' . 'flow_id' . '}',
                ObjectSerializer::toPathValue($flow_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Api-Key');
        if ($apiKey !== null) {
            $headers['Api-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation invokeFlow
     *
     * Invoke Flow
     *
     * @param  string $flow_id flow_id (required)
     * @param  string $workspace_id workspace_id (required)
     * @param  \FlowHunt\Model\FlowInvokeRequest $flow_invoke_request flow_invoke_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invokeFlow'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\TaskResponse|\FlowHunt\Model\HTTPValidationError
     */
    public function invokeFlow($flow_id, $workspace_id, $flow_invoke_request, string $contentType = self::contentTypes['invokeFlow'][0])
    {
        list($response) = $this->invokeFlowWithHttpInfo($flow_id, $workspace_id, $flow_invoke_request, $contentType);
        return $response;
    }

    /**
     * Operation invokeFlowWithHttpInfo
     *
     * Invoke Flow
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowInvokeRequest $flow_invoke_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invokeFlow'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\TaskResponse|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function invokeFlowWithHttpInfo($flow_id, $workspace_id, $flow_invoke_request, string $contentType = self::contentTypes['invokeFlow'][0])
    {
        $request = $this->invokeFlowRequest($flow_id, $workspace_id, $flow_invoke_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\TaskResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\TaskResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\TaskResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation invokeFlowAsync
     *
     * Invoke Flow
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowInvokeRequest $flow_invoke_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invokeFlow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invokeFlowAsync($flow_id, $workspace_id, $flow_invoke_request, string $contentType = self::contentTypes['invokeFlow'][0])
    {
        return $this->invokeFlowAsyncWithHttpInfo($flow_id, $workspace_id, $flow_invoke_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation invokeFlowAsyncWithHttpInfo
     *
     * Invoke Flow
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowInvokeRequest $flow_invoke_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invokeFlow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invokeFlowAsyncWithHttpInfo($flow_id, $workspace_id, $flow_invoke_request, string $contentType = self::contentTypes['invokeFlow'][0])
    {
        $returnType = '\FlowHunt\Model\TaskResponse';
        $request = $this->invokeFlowRequest($flow_id, $workspace_id, $flow_invoke_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'invokeFlow'
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowInvokeRequest $flow_invoke_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invokeFlow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function invokeFlowRequest($flow_id, $workspace_id, $flow_invoke_request, string $contentType = self::contentTypes['invokeFlow'][0])
    {

        // verify the required parameter 'flow_id' is set
        if ($flow_id === null || (is_array($flow_id) && count($flow_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_id when calling invokeFlow'
            );
        }

        // verify the required parameter 'workspace_id' is set
        if ($workspace_id === null || (is_array($workspace_id) && count($workspace_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workspace_id when calling invokeFlow'
            );
        }

        // verify the required parameter 'flow_invoke_request' is set
        if ($flow_invoke_request === null || (is_array($flow_invoke_request) && count($flow_invoke_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_invoke_request when calling invokeFlow'
            );
        }


        $resourcePath = '/v2/flows/{flow_id}/invoke';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $workspace_id,
            'workspace_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($flow_id !== null) {
            $resourcePath = str_replace(
                '{' . 'flow_id' . '}',
                ObjectSerializer::toPathValue($flow_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($flow_invoke_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($flow_invoke_request));
            } else {
                $httpBody = $flow_invoke_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Api-Key');
        if ($apiKey !== null) {
            $headers['Api-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation invokeFlowResponse
     *
     * Invoke Flow Response
     *
     * @param  string $session_id session_id (required)
     * @param  \FlowHunt\Model\FlowSessionInvokeRequest $flow_session_invoke_request flow_session_invoke_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invokeFlowResponse'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\FlowSessionInvocationResponse|\FlowHunt\Model\HTTPValidationError
     */
    public function invokeFlowResponse($session_id, $flow_session_invoke_request, string $contentType = self::contentTypes['invokeFlowResponse'][0])
    {
        list($response) = $this->invokeFlowResponseWithHttpInfo($session_id, $flow_session_invoke_request, $contentType);
        return $response;
    }

    /**
     * Operation invokeFlowResponseWithHttpInfo
     *
     * Invoke Flow Response
     *
     * @param  string $session_id (required)
     * @param  \FlowHunt\Model\FlowSessionInvokeRequest $flow_session_invoke_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invokeFlowResponse'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\FlowSessionInvocationResponse|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function invokeFlowResponseWithHttpInfo($session_id, $flow_session_invoke_request, string $contentType = self::contentTypes['invokeFlowResponse'][0])
    {
        $request = $this->invokeFlowResponseRequest($session_id, $flow_session_invoke_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\FlowSessionInvocationResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\FlowSessionInvocationResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\FlowSessionInvocationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation invokeFlowResponseAsync
     *
     * Invoke Flow Response
     *
     * @param  string $session_id (required)
     * @param  \FlowHunt\Model\FlowSessionInvokeRequest $flow_session_invoke_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invokeFlowResponse'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invokeFlowResponseAsync($session_id, $flow_session_invoke_request, string $contentType = self::contentTypes['invokeFlowResponse'][0])
    {
        return $this->invokeFlowResponseAsyncWithHttpInfo($session_id, $flow_session_invoke_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation invokeFlowResponseAsyncWithHttpInfo
     *
     * Invoke Flow Response
     *
     * @param  string $session_id (required)
     * @param  \FlowHunt\Model\FlowSessionInvokeRequest $flow_session_invoke_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invokeFlowResponse'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invokeFlowResponseAsyncWithHttpInfo($session_id, $flow_session_invoke_request, string $contentType = self::contentTypes['invokeFlowResponse'][0])
    {
        $returnType = '\FlowHunt\Model\FlowSessionInvocationResponse';
        $request = $this->invokeFlowResponseRequest($session_id, $flow_session_invoke_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'invokeFlowResponse'
     *
     * @param  string $session_id (required)
     * @param  \FlowHunt\Model\FlowSessionInvokeRequest $flow_session_invoke_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invokeFlowResponse'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function invokeFlowResponseRequest($session_id, $flow_session_invoke_request, string $contentType = self::contentTypes['invokeFlowResponse'][0])
    {

        // verify the required parameter 'session_id' is set
        if ($session_id === null || (is_array($session_id) && count($session_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $session_id when calling invokeFlowResponse'
            );
        }

        // verify the required parameter 'flow_session_invoke_request' is set
        if ($flow_session_invoke_request === null || (is_array($flow_session_invoke_request) && count($flow_session_invoke_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_session_invoke_request when calling invokeFlowResponse'
            );
        }


        $resourcePath = '/v2/flows/sessions/{session_id}/invoke';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($session_id !== null) {
            $resourcePath = str_replace(
                '{' . 'session_id' . '}',
                ObjectSerializer::toPathValue($session_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($flow_session_invoke_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($flow_session_invoke_request));
            } else {
                $httpBody = $flow_session_invoke_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation invokeFlowSingleton
     *
     * Invoke Flow Singleton
     *
     * @param  string $flow_id flow_id (required)
     * @param  string $workspace_id workspace_id (required)
     * @param  \FlowHunt\Model\FlowInvokeRequest $flow_invoke_request flow_invoke_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invokeFlowSingleton'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\TaskResponse|\FlowHunt\Model\HTTPValidationError
     */
    public function invokeFlowSingleton($flow_id, $workspace_id, $flow_invoke_request, string $contentType = self::contentTypes['invokeFlowSingleton'][0])
    {
        list($response) = $this->invokeFlowSingletonWithHttpInfo($flow_id, $workspace_id, $flow_invoke_request, $contentType);
        return $response;
    }

    /**
     * Operation invokeFlowSingletonWithHttpInfo
     *
     * Invoke Flow Singleton
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowInvokeRequest $flow_invoke_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invokeFlowSingleton'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\TaskResponse|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function invokeFlowSingletonWithHttpInfo($flow_id, $workspace_id, $flow_invoke_request, string $contentType = self::contentTypes['invokeFlowSingleton'][0])
    {
        $request = $this->invokeFlowSingletonRequest($flow_id, $workspace_id, $flow_invoke_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\TaskResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\TaskResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\TaskResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation invokeFlowSingletonAsync
     *
     * Invoke Flow Singleton
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowInvokeRequest $flow_invoke_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invokeFlowSingleton'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invokeFlowSingletonAsync($flow_id, $workspace_id, $flow_invoke_request, string $contentType = self::contentTypes['invokeFlowSingleton'][0])
    {
        return $this->invokeFlowSingletonAsyncWithHttpInfo($flow_id, $workspace_id, $flow_invoke_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation invokeFlowSingletonAsyncWithHttpInfo
     *
     * Invoke Flow Singleton
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowInvokeRequest $flow_invoke_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invokeFlowSingleton'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invokeFlowSingletonAsyncWithHttpInfo($flow_id, $workspace_id, $flow_invoke_request, string $contentType = self::contentTypes['invokeFlowSingleton'][0])
    {
        $returnType = '\FlowHunt\Model\TaskResponse';
        $request = $this->invokeFlowSingletonRequest($flow_id, $workspace_id, $flow_invoke_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'invokeFlowSingleton'
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowInvokeRequest $flow_invoke_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invokeFlowSingleton'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function invokeFlowSingletonRequest($flow_id, $workspace_id, $flow_invoke_request, string $contentType = self::contentTypes['invokeFlowSingleton'][0])
    {

        // verify the required parameter 'flow_id' is set
        if ($flow_id === null || (is_array($flow_id) && count($flow_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_id when calling invokeFlowSingleton'
            );
        }

        // verify the required parameter 'workspace_id' is set
        if ($workspace_id === null || (is_array($workspace_id) && count($workspace_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workspace_id when calling invokeFlowSingleton'
            );
        }

        // verify the required parameter 'flow_invoke_request' is set
        if ($flow_invoke_request === null || (is_array($flow_invoke_request) && count($flow_invoke_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_invoke_request when calling invokeFlowSingleton'
            );
        }


        $resourcePath = '/v2/flows/{flow_id}/invoke_singleton';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $workspace_id,
            'workspace_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($flow_id !== null) {
            $resourcePath = str_replace(
                '{' . 'flow_id' . '}',
                ObjectSerializer::toPathValue($flow_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($flow_invoke_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($flow_invoke_request));
            } else {
                $httpBody = $flow_invoke_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Api-Key');
        if ($apiKey !== null) {
            $headers['Api-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pollFlowResponse
     *
     * Poll Flow Response
     *
     * @param  string $session_id session_id (required)
     * @param  string $from_timestamp from_timestamp (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pollFlowResponse'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\FlowSessionEvent[]|\FlowHunt\Model\HTTPValidationError
     */
    public function pollFlowResponse($session_id, $from_timestamp, string $contentType = self::contentTypes['pollFlowResponse'][0])
    {
        list($response) = $this->pollFlowResponseWithHttpInfo($session_id, $from_timestamp, $contentType);
        return $response;
    }

    /**
     * Operation pollFlowResponseWithHttpInfo
     *
     * Poll Flow Response
     *
     * @param  string $session_id (required)
     * @param  string $from_timestamp (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pollFlowResponse'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\FlowSessionEvent[]|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function pollFlowResponseWithHttpInfo($session_id, $from_timestamp, string $contentType = self::contentTypes['pollFlowResponse'][0])
    {
        $request = $this->pollFlowResponseRequest($session_id, $from_timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\FlowSessionEvent[]',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\FlowSessionEvent[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\FlowSessionEvent[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation pollFlowResponseAsync
     *
     * Poll Flow Response
     *
     * @param  string $session_id (required)
     * @param  string $from_timestamp (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pollFlowResponse'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pollFlowResponseAsync($session_id, $from_timestamp, string $contentType = self::contentTypes['pollFlowResponse'][0])
    {
        return $this->pollFlowResponseAsyncWithHttpInfo($session_id, $from_timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pollFlowResponseAsyncWithHttpInfo
     *
     * Poll Flow Response
     *
     * @param  string $session_id (required)
     * @param  string $from_timestamp (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pollFlowResponse'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pollFlowResponseAsyncWithHttpInfo($session_id, $from_timestamp, string $contentType = self::contentTypes['pollFlowResponse'][0])
    {
        $returnType = '\FlowHunt\Model\FlowSessionEvent[]';
        $request = $this->pollFlowResponseRequest($session_id, $from_timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pollFlowResponse'
     *
     * @param  string $session_id (required)
     * @param  string $from_timestamp (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pollFlowResponse'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function pollFlowResponseRequest($session_id, $from_timestamp, string $contentType = self::contentTypes['pollFlowResponse'][0])
    {

        // verify the required parameter 'session_id' is set
        if ($session_id === null || (is_array($session_id) && count($session_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $session_id when calling pollFlowResponse'
            );
        }

        // verify the required parameter 'from_timestamp' is set
        if ($from_timestamp === null || (is_array($from_timestamp) && count($from_timestamp) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from_timestamp when calling pollFlowResponse'
            );
        }


        $resourcePath = '/v2/flows/sessions/{session_id}/invocation_response/{from_timestamp}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($session_id !== null) {
            $resourcePath = str_replace(
                '{' . 'session_id' . '}',
                ObjectSerializer::toPathValue($session_id),
                $resourcePath
            );
        }
        // path params
        if ($from_timestamp !== null) {
            $resourcePath = str_replace(
                '{' . 'from_timestamp' . '}',
                ObjectSerializer::toPathValue($from_timestamp),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation publishFlow
     *
     * Publish Flow
     *
     * @param  string $flow_id flow_id (required)
     * @param  string $workspace_id workspace_id (required)
     * @param  \FlowHunt\Model\FlowCommitRequest $flow_commit_request flow_commit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishFlow'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\FlowDetailResponse|\FlowHunt\Model\HTTPValidationError
     */
    public function publishFlow($flow_id, $workspace_id, $flow_commit_request, string $contentType = self::contentTypes['publishFlow'][0])
    {
        list($response) = $this->publishFlowWithHttpInfo($flow_id, $workspace_id, $flow_commit_request, $contentType);
        return $response;
    }

    /**
     * Operation publishFlowWithHttpInfo
     *
     * Publish Flow
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCommitRequest $flow_commit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishFlow'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\FlowDetailResponse|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function publishFlowWithHttpInfo($flow_id, $workspace_id, $flow_commit_request, string $contentType = self::contentTypes['publishFlow'][0])
    {
        $request = $this->publishFlowRequest($flow_id, $workspace_id, $flow_commit_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\FlowDetailResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\FlowDetailResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\FlowDetailResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation publishFlowAsync
     *
     * Publish Flow
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCommitRequest $flow_commit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishFlow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function publishFlowAsync($flow_id, $workspace_id, $flow_commit_request, string $contentType = self::contentTypes['publishFlow'][0])
    {
        return $this->publishFlowAsyncWithHttpInfo($flow_id, $workspace_id, $flow_commit_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation publishFlowAsyncWithHttpInfo
     *
     * Publish Flow
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCommitRequest $flow_commit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishFlow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function publishFlowAsyncWithHttpInfo($flow_id, $workspace_id, $flow_commit_request, string $contentType = self::contentTypes['publishFlow'][0])
    {
        $returnType = '\FlowHunt\Model\FlowDetailResponse';
        $request = $this->publishFlowRequest($flow_id, $workspace_id, $flow_commit_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'publishFlow'
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCommitRequest $flow_commit_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishFlow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function publishFlowRequest($flow_id, $workspace_id, $flow_commit_request, string $contentType = self::contentTypes['publishFlow'][0])
    {

        // verify the required parameter 'flow_id' is set
        if ($flow_id === null || (is_array($flow_id) && count($flow_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_id when calling publishFlow'
            );
        }

        // verify the required parameter 'workspace_id' is set
        if ($workspace_id === null || (is_array($workspace_id) && count($workspace_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workspace_id when calling publishFlow'
            );
        }

        // verify the required parameter 'flow_commit_request' is set
        if ($flow_commit_request === null || (is_array($flow_commit_request) && count($flow_commit_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_commit_request when calling publishFlow'
            );
        }


        $resourcePath = '/v2/flows/{flow_id}/publish';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $workspace_id,
            'workspace_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($flow_id !== null) {
            $resourcePath = str_replace(
                '{' . 'flow_id' . '}',
                ObjectSerializer::toPathValue($flow_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($flow_commit_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($flow_commit_request));
            } else {
                $httpBody = $flow_commit_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Api-Key');
        if ($apiKey !== null) {
            $headers['Api-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restoreFlowVersion
     *
     * Restore Flow Version
     *
     * @param  string $flow_id flow_id (required)
     * @param  string $branch branch (required)
     * @param  string $workspace_id workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreFlowVersion'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\Completed|\FlowHunt\Model\HTTPValidationError
     */
    public function restoreFlowVersion($flow_id, $branch, $workspace_id, string $contentType = self::contentTypes['restoreFlowVersion'][0])
    {
        list($response) = $this->restoreFlowVersionWithHttpInfo($flow_id, $branch, $workspace_id, $contentType);
        return $response;
    }

    /**
     * Operation restoreFlowVersionWithHttpInfo
     *
     * Restore Flow Version
     *
     * @param  string $flow_id (required)
     * @param  string $branch (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreFlowVersion'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\Completed|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function restoreFlowVersionWithHttpInfo($flow_id, $branch, $workspace_id, string $contentType = self::contentTypes['restoreFlowVersion'][0])
    {
        $request = $this->restoreFlowVersionRequest($flow_id, $branch, $workspace_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\Completed',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\Completed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\Completed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation restoreFlowVersionAsync
     *
     * Restore Flow Version
     *
     * @param  string $flow_id (required)
     * @param  string $branch (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreFlowVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restoreFlowVersionAsync($flow_id, $branch, $workspace_id, string $contentType = self::contentTypes['restoreFlowVersion'][0])
    {
        return $this->restoreFlowVersionAsyncWithHttpInfo($flow_id, $branch, $workspace_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restoreFlowVersionAsyncWithHttpInfo
     *
     * Restore Flow Version
     *
     * @param  string $flow_id (required)
     * @param  string $branch (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreFlowVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restoreFlowVersionAsyncWithHttpInfo($flow_id, $branch, $workspace_id, string $contentType = self::contentTypes['restoreFlowVersion'][0])
    {
        $returnType = '\FlowHunt\Model\Completed';
        $request = $this->restoreFlowVersionRequest($flow_id, $branch, $workspace_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restoreFlowVersion'
     *
     * @param  string $flow_id (required)
     * @param  string $branch (required)
     * @param  string $workspace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreFlowVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restoreFlowVersionRequest($flow_id, $branch, $workspace_id, string $contentType = self::contentTypes['restoreFlowVersion'][0])
    {

        // verify the required parameter 'flow_id' is set
        if ($flow_id === null || (is_array($flow_id) && count($flow_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_id when calling restoreFlowVersion'
            );
        }

        // verify the required parameter 'branch' is set
        if ($branch === null || (is_array($branch) && count($branch) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $branch when calling restoreFlowVersion'
            );
        }

        // verify the required parameter 'workspace_id' is set
        if ($workspace_id === null || (is_array($workspace_id) && count($workspace_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workspace_id when calling restoreFlowVersion'
            );
        }


        $resourcePath = '/v2/flows/{flow_id}/version_history/{branch}/restore';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $workspace_id,
            'workspace_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($flow_id !== null) {
            $resourcePath = str_replace(
                '{' . 'flow_id' . '}',
                ObjectSerializer::toPathValue($flow_id),
                $resourcePath
            );
        }
        // path params
        if ($branch !== null) {
            $resourcePath = str_replace(
                '{' . 'branch' . '}',
                ObjectSerializer::toPathValue($branch),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Api-Key');
        if ($apiKey !== null) {
            $headers['Api-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation search
     *
     * Search
     *
     * @param  string $workspace_id workspace_id (required)
     * @param  \FlowHunt\Model\FlowSearchRequest $flow_search_request flow_search_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['search'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\FlowResponse[]|\FlowHunt\Model\HTTPValidationError
     */
    public function search($workspace_id, $flow_search_request, string $contentType = self::contentTypes['search'][0])
    {
        list($response) = $this->searchWithHttpInfo($workspace_id, $flow_search_request, $contentType);
        return $response;
    }

    /**
     * Operation searchWithHttpInfo
     *
     * Search
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowSearchRequest $flow_search_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['search'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\FlowResponse[]|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchWithHttpInfo($workspace_id, $flow_search_request, string $contentType = self::contentTypes['search'][0])
    {
        $request = $this->searchRequest($workspace_id, $flow_search_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\FlowResponse[]',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\FlowResponse[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\FlowResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchAsync
     *
     * Search
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowSearchRequest $flow_search_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['search'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAsync($workspace_id, $flow_search_request, string $contentType = self::contentTypes['search'][0])
    {
        return $this->searchAsyncWithHttpInfo($workspace_id, $flow_search_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchAsyncWithHttpInfo
     *
     * Search
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowSearchRequest $flow_search_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['search'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAsyncWithHttpInfo($workspace_id, $flow_search_request, string $contentType = self::contentTypes['search'][0])
    {
        $returnType = '\FlowHunt\Model\FlowResponse[]';
        $request = $this->searchRequest($workspace_id, $flow_search_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'search'
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowSearchRequest $flow_search_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['search'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchRequest($workspace_id, $flow_search_request, string $contentType = self::contentTypes['search'][0])
    {

        // verify the required parameter 'workspace_id' is set
        if ($workspace_id === null || (is_array($workspace_id) && count($workspace_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workspace_id when calling search'
            );
        }

        // verify the required parameter 'flow_search_request' is set
        if ($flow_search_request === null || (is_array($flow_search_request) && count($flow_search_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_search_request when calling search'
            );
        }


        $resourcePath = '/v2/flows/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $workspace_id,
            'workspace_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($flow_search_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($flow_search_request));
            } else {
                $httpBody = $flow_search_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Api-Key');
        if ($apiKey !== null) {
            $headers['Api-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchAll
     *
     * Search All
     *
     * @param  string $workspace_id workspace_id (required)
     * @param  \FlowHunt\Model\AllFlowsSearchRequest $all_flows_search_request all_flows_search_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchAll'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\FlowResponse[]|\FlowHunt\Model\HTTPValidationError
     */
    public function searchAll($workspace_id, $all_flows_search_request, string $contentType = self::contentTypes['searchAll'][0])
    {
        list($response) = $this->searchAllWithHttpInfo($workspace_id, $all_flows_search_request, $contentType);
        return $response;
    }

    /**
     * Operation searchAllWithHttpInfo
     *
     * Search All
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\AllFlowsSearchRequest $all_flows_search_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchAll'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\FlowResponse[]|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchAllWithHttpInfo($workspace_id, $all_flows_search_request, string $contentType = self::contentTypes['searchAll'][0])
    {
        $request = $this->searchAllRequest($workspace_id, $all_flows_search_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\FlowResponse[]',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\FlowResponse[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\FlowResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchAllAsync
     *
     * Search All
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\AllFlowsSearchRequest $all_flows_search_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAllAsync($workspace_id, $all_flows_search_request, string $contentType = self::contentTypes['searchAll'][0])
    {
        return $this->searchAllAsyncWithHttpInfo($workspace_id, $all_flows_search_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchAllAsyncWithHttpInfo
     *
     * Search All
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\AllFlowsSearchRequest $all_flows_search_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAllAsyncWithHttpInfo($workspace_id, $all_flows_search_request, string $contentType = self::contentTypes['searchAll'][0])
    {
        $returnType = '\FlowHunt\Model\FlowResponse[]';
        $request = $this->searchAllRequest($workspace_id, $all_flows_search_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchAll'
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\AllFlowsSearchRequest $all_flows_search_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchAllRequest($workspace_id, $all_flows_search_request, string $contentType = self::contentTypes['searchAll'][0])
    {

        // verify the required parameter 'workspace_id' is set
        if ($workspace_id === null || (is_array($workspace_id) && count($workspace_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workspace_id when calling searchAll'
            );
        }

        // verify the required parameter 'all_flows_search_request' is set
        if ($all_flows_search_request === null || (is_array($all_flows_search_request) && count($all_flows_search_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $all_flows_search_request when calling searchAll'
            );
        }


        $resourcePath = '/v2/flows/all';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $workspace_id,
            'workspace_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($all_flows_search_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($all_flows_search_request));
            } else {
                $httpBody = $all_flows_search_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Api-Key');
        if ($apiKey !== null) {
            $headers['Api-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchFlowCategories
     *
     * Search Flow Categories
     *
     * @param  string $workspace_id workspace_id (required)
     * @param  \FlowHunt\Model\FlowCategorySearchRequest $flow_category_search_request flow_category_search_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchFlowCategories'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\FlowCategoryResponse[]|\FlowHunt\Model\HTTPValidationError
     */
    public function searchFlowCategories($workspace_id, $flow_category_search_request, string $contentType = self::contentTypes['searchFlowCategories'][0])
    {
        list($response) = $this->searchFlowCategoriesWithHttpInfo($workspace_id, $flow_category_search_request, $contentType);
        return $response;
    }

    /**
     * Operation searchFlowCategoriesWithHttpInfo
     *
     * Search Flow Categories
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCategorySearchRequest $flow_category_search_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchFlowCategories'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\FlowCategoryResponse[]|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchFlowCategoriesWithHttpInfo($workspace_id, $flow_category_search_request, string $contentType = self::contentTypes['searchFlowCategories'][0])
    {
        $request = $this->searchFlowCategoriesRequest($workspace_id, $flow_category_search_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\FlowCategoryResponse[]',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\FlowCategoryResponse[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\FlowCategoryResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchFlowCategoriesAsync
     *
     * Search Flow Categories
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCategorySearchRequest $flow_category_search_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchFlowCategories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchFlowCategoriesAsync($workspace_id, $flow_category_search_request, string $contentType = self::contentTypes['searchFlowCategories'][0])
    {
        return $this->searchFlowCategoriesAsyncWithHttpInfo($workspace_id, $flow_category_search_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchFlowCategoriesAsyncWithHttpInfo
     *
     * Search Flow Categories
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCategorySearchRequest $flow_category_search_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchFlowCategories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchFlowCategoriesAsyncWithHttpInfo($workspace_id, $flow_category_search_request, string $contentType = self::contentTypes['searchFlowCategories'][0])
    {
        $returnType = '\FlowHunt\Model\FlowCategoryResponse[]';
        $request = $this->searchFlowCategoriesRequest($workspace_id, $flow_category_search_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchFlowCategories'
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCategorySearchRequest $flow_category_search_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchFlowCategories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchFlowCategoriesRequest($workspace_id, $flow_category_search_request, string $contentType = self::contentTypes['searchFlowCategories'][0])
    {

        // verify the required parameter 'workspace_id' is set
        if ($workspace_id === null || (is_array($workspace_id) && count($workspace_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workspace_id when calling searchFlowCategories'
            );
        }

        // verify the required parameter 'flow_category_search_request' is set
        if ($flow_category_search_request === null || (is_array($flow_category_search_request) && count($flow_category_search_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_category_search_request when calling searchFlowCategories'
            );
        }


        $resourcePath = '/v2/flows/categories/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $workspace_id,
            'workspace_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($flow_category_search_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($flow_category_search_request));
            } else {
                $httpBody = $flow_category_search_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Api-Key');
        if ($apiKey !== null) {
            $headers['Api-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchFlowCrons
     *
     * Search Flow Crons
     *
     * @param  string $workspace_id workspace_id (required)
     * @param  \FlowHunt\Model\FlowCronSearchRequest $flow_cron_search_request flow_cron_search_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchFlowCrons'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\FlowCronResponse[]|\FlowHunt\Model\HTTPValidationError
     */
    public function searchFlowCrons($workspace_id, $flow_cron_search_request, string $contentType = self::contentTypes['searchFlowCrons'][0])
    {
        list($response) = $this->searchFlowCronsWithHttpInfo($workspace_id, $flow_cron_search_request, $contentType);
        return $response;
    }

    /**
     * Operation searchFlowCronsWithHttpInfo
     *
     * Search Flow Crons
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCronSearchRequest $flow_cron_search_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchFlowCrons'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\FlowCronResponse[]|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchFlowCronsWithHttpInfo($workspace_id, $flow_cron_search_request, string $contentType = self::contentTypes['searchFlowCrons'][0])
    {
        $request = $this->searchFlowCronsRequest($workspace_id, $flow_cron_search_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\FlowCronResponse[]',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\FlowCronResponse[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\FlowCronResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchFlowCronsAsync
     *
     * Search Flow Crons
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCronSearchRequest $flow_cron_search_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchFlowCrons'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchFlowCronsAsync($workspace_id, $flow_cron_search_request, string $contentType = self::contentTypes['searchFlowCrons'][0])
    {
        return $this->searchFlowCronsAsyncWithHttpInfo($workspace_id, $flow_cron_search_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchFlowCronsAsyncWithHttpInfo
     *
     * Search Flow Crons
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCronSearchRequest $flow_cron_search_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchFlowCrons'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchFlowCronsAsyncWithHttpInfo($workspace_id, $flow_cron_search_request, string $contentType = self::contentTypes['searchFlowCrons'][0])
    {
        $returnType = '\FlowHunt\Model\FlowCronResponse[]';
        $request = $this->searchFlowCronsRequest($workspace_id, $flow_cron_search_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchFlowCrons'
     *
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCronSearchRequest $flow_cron_search_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchFlowCrons'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchFlowCronsRequest($workspace_id, $flow_cron_search_request, string $contentType = self::contentTypes['searchFlowCrons'][0])
    {

        // verify the required parameter 'workspace_id' is set
        if ($workspace_id === null || (is_array($workspace_id) && count($workspace_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workspace_id when calling searchFlowCrons'
            );
        }

        // verify the required parameter 'flow_cron_search_request' is set
        if ($flow_cron_search_request === null || (is_array($flow_cron_search_request) && count($flow_cron_search_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_cron_search_request when calling searchFlowCrons'
            );
        }


        $resourcePath = '/v2/flows/crons/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $workspace_id,
            'workspace_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($flow_cron_search_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($flow_cron_search_request));
            } else {
                $httpBody = $flow_cron_search_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Api-Key');
        if ($apiKey !== null) {
            $headers['Api-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateFlow
     *
     * Update Flow
     *
     * @param  string $flow_id flow_id (required)
     * @param  string $workspace_id workspace_id (required)
     * @param  \FlowHunt\Model\FlowUpdate $flow_update flow_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFlow'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\FlowDetailResponse|\FlowHunt\Model\HTTPValidationError
     */
    public function updateFlow($flow_id, $workspace_id, $flow_update, string $contentType = self::contentTypes['updateFlow'][0])
    {
        list($response) = $this->updateFlowWithHttpInfo($flow_id, $workspace_id, $flow_update, $contentType);
        return $response;
    }

    /**
     * Operation updateFlowWithHttpInfo
     *
     * Update Flow
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowUpdate $flow_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFlow'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\FlowDetailResponse|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateFlowWithHttpInfo($flow_id, $workspace_id, $flow_update, string $contentType = self::contentTypes['updateFlow'][0])
    {
        $request = $this->updateFlowRequest($flow_id, $workspace_id, $flow_update, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\FlowDetailResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\FlowDetailResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\FlowDetailResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateFlowAsync
     *
     * Update Flow
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowUpdate $flow_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFlow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFlowAsync($flow_id, $workspace_id, $flow_update, string $contentType = self::contentTypes['updateFlow'][0])
    {
        return $this->updateFlowAsyncWithHttpInfo($flow_id, $workspace_id, $flow_update, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateFlowAsyncWithHttpInfo
     *
     * Update Flow
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowUpdate $flow_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFlow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFlowAsyncWithHttpInfo($flow_id, $workspace_id, $flow_update, string $contentType = self::contentTypes['updateFlow'][0])
    {
        $returnType = '\FlowHunt\Model\FlowDetailResponse';
        $request = $this->updateFlowRequest($flow_id, $workspace_id, $flow_update, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateFlow'
     *
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowUpdate $flow_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFlow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateFlowRequest($flow_id, $workspace_id, $flow_update, string $contentType = self::contentTypes['updateFlow'][0])
    {

        // verify the required parameter 'flow_id' is set
        if ($flow_id === null || (is_array($flow_id) && count($flow_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_id when calling updateFlow'
            );
        }

        // verify the required parameter 'workspace_id' is set
        if ($workspace_id === null || (is_array($workspace_id) && count($workspace_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workspace_id when calling updateFlow'
            );
        }

        // verify the required parameter 'flow_update' is set
        if ($flow_update === null || (is_array($flow_update) && count($flow_update) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_update when calling updateFlow'
            );
        }


        $resourcePath = '/v2/flows/{flow_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $workspace_id,
            'workspace_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($flow_id !== null) {
            $resourcePath = str_replace(
                '{' . 'flow_id' . '}',
                ObjectSerializer::toPathValue($flow_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($flow_update)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($flow_update));
            } else {
                $httpBody = $flow_update;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Api-Key');
        if ($apiKey !== null) {
            $headers['Api-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateFlowCategory
     *
     * Update Flow Category
     *
     * @param  string $cat_id cat_id (required)
     * @param  string $workspace_id workspace_id (required)
     * @param  \FlowHunt\Model\FlowCategoryCreateRequest $flow_category_create_request flow_category_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFlowCategory'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\FlowCategoryResponse|\FlowHunt\Model\HTTPValidationError
     */
    public function updateFlowCategory($cat_id, $workspace_id, $flow_category_create_request, string $contentType = self::contentTypes['updateFlowCategory'][0])
    {
        list($response) = $this->updateFlowCategoryWithHttpInfo($cat_id, $workspace_id, $flow_category_create_request, $contentType);
        return $response;
    }

    /**
     * Operation updateFlowCategoryWithHttpInfo
     *
     * Update Flow Category
     *
     * @param  string $cat_id (required)
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCategoryCreateRequest $flow_category_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFlowCategory'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\FlowCategoryResponse|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateFlowCategoryWithHttpInfo($cat_id, $workspace_id, $flow_category_create_request, string $contentType = self::contentTypes['updateFlowCategory'][0])
    {
        $request = $this->updateFlowCategoryRequest($cat_id, $workspace_id, $flow_category_create_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\FlowCategoryResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\FlowCategoryResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\FlowCategoryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateFlowCategoryAsync
     *
     * Update Flow Category
     *
     * @param  string $cat_id (required)
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCategoryCreateRequest $flow_category_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFlowCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFlowCategoryAsync($cat_id, $workspace_id, $flow_category_create_request, string $contentType = self::contentTypes['updateFlowCategory'][0])
    {
        return $this->updateFlowCategoryAsyncWithHttpInfo($cat_id, $workspace_id, $flow_category_create_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateFlowCategoryAsyncWithHttpInfo
     *
     * Update Flow Category
     *
     * @param  string $cat_id (required)
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCategoryCreateRequest $flow_category_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFlowCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFlowCategoryAsyncWithHttpInfo($cat_id, $workspace_id, $flow_category_create_request, string $contentType = self::contentTypes['updateFlowCategory'][0])
    {
        $returnType = '\FlowHunt\Model\FlowCategoryResponse';
        $request = $this->updateFlowCategoryRequest($cat_id, $workspace_id, $flow_category_create_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateFlowCategory'
     *
     * @param  string $cat_id (required)
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCategoryCreateRequest $flow_category_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFlowCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateFlowCategoryRequest($cat_id, $workspace_id, $flow_category_create_request, string $contentType = self::contentTypes['updateFlowCategory'][0])
    {

        // verify the required parameter 'cat_id' is set
        if ($cat_id === null || (is_array($cat_id) && count($cat_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cat_id when calling updateFlowCategory'
            );
        }

        // verify the required parameter 'workspace_id' is set
        if ($workspace_id === null || (is_array($workspace_id) && count($workspace_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workspace_id when calling updateFlowCategory'
            );
        }

        // verify the required parameter 'flow_category_create_request' is set
        if ($flow_category_create_request === null || (is_array($flow_category_create_request) && count($flow_category_create_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_category_create_request when calling updateFlowCategory'
            );
        }


        $resourcePath = '/v2/flows/categories/{cat_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $workspace_id,
            'workspace_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($cat_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cat_id' . '}',
                ObjectSerializer::toPathValue($cat_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($flow_category_create_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($flow_category_create_request));
            } else {
                $httpBody = $flow_category_create_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Api-Key');
        if ($apiKey !== null) {
            $headers['Api-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateFlowCron
     *
     * Update Flow Cron
     *
     * @param  string $cron_id cron_id (required)
     * @param  string $flow_id flow_id (required)
     * @param  string $workspace_id workspace_id (required)
     * @param  \FlowHunt\Model\FlowCronUpdateRequest $flow_cron_update_request flow_cron_update_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFlowCron'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\FlowCronResponse|\FlowHunt\Model\HTTPValidationError
     */
    public function updateFlowCron($cron_id, $flow_id, $workspace_id, $flow_cron_update_request, string $contentType = self::contentTypes['updateFlowCron'][0])
    {
        list($response) = $this->updateFlowCronWithHttpInfo($cron_id, $flow_id, $workspace_id, $flow_cron_update_request, $contentType);
        return $response;
    }

    /**
     * Operation updateFlowCronWithHttpInfo
     *
     * Update Flow Cron
     *
     * @param  string $cron_id (required)
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCronUpdateRequest $flow_cron_update_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFlowCron'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\FlowCronResponse|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateFlowCronWithHttpInfo($cron_id, $flow_id, $workspace_id, $flow_cron_update_request, string $contentType = self::contentTypes['updateFlowCron'][0])
    {
        $request = $this->updateFlowCronRequest($cron_id, $flow_id, $workspace_id, $flow_cron_update_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\FlowCronResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\FlowCronResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\FlowCronResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateFlowCronAsync
     *
     * Update Flow Cron
     *
     * @param  string $cron_id (required)
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCronUpdateRequest $flow_cron_update_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFlowCron'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFlowCronAsync($cron_id, $flow_id, $workspace_id, $flow_cron_update_request, string $contentType = self::contentTypes['updateFlowCron'][0])
    {
        return $this->updateFlowCronAsyncWithHttpInfo($cron_id, $flow_id, $workspace_id, $flow_cron_update_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateFlowCronAsyncWithHttpInfo
     *
     * Update Flow Cron
     *
     * @param  string $cron_id (required)
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCronUpdateRequest $flow_cron_update_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFlowCron'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFlowCronAsyncWithHttpInfo($cron_id, $flow_id, $workspace_id, $flow_cron_update_request, string $contentType = self::contentTypes['updateFlowCron'][0])
    {
        $returnType = '\FlowHunt\Model\FlowCronResponse';
        $request = $this->updateFlowCronRequest($cron_id, $flow_id, $workspace_id, $flow_cron_update_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateFlowCron'
     *
     * @param  string $cron_id (required)
     * @param  string $flow_id (required)
     * @param  string $workspace_id (required)
     * @param  \FlowHunt\Model\FlowCronUpdateRequest $flow_cron_update_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFlowCron'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateFlowCronRequest($cron_id, $flow_id, $workspace_id, $flow_cron_update_request, string $contentType = self::contentTypes['updateFlowCron'][0])
    {

        // verify the required parameter 'cron_id' is set
        if ($cron_id === null || (is_array($cron_id) && count($cron_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cron_id when calling updateFlowCron'
            );
        }

        // verify the required parameter 'flow_id' is set
        if ($flow_id === null || (is_array($flow_id) && count($flow_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_id when calling updateFlowCron'
            );
        }

        // verify the required parameter 'workspace_id' is set
        if ($workspace_id === null || (is_array($workspace_id) && count($workspace_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workspace_id when calling updateFlowCron'
            );
        }

        // verify the required parameter 'flow_cron_update_request' is set
        if ($flow_cron_update_request === null || (is_array($flow_cron_update_request) && count($flow_cron_update_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_cron_update_request when calling updateFlowCron'
            );
        }


        $resourcePath = '/v2/flows/crons/{flow_id}/{cron_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $workspace_id,
            'workspace_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($cron_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cron_id' . '}',
                ObjectSerializer::toPathValue($cron_id),
                $resourcePath
            );
        }
        // path params
        if ($flow_id !== null) {
            $resourcePath = str_replace(
                '{' . 'flow_id' . '}',
                ObjectSerializer::toPathValue($flow_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($flow_cron_update_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($flow_cron_update_request));
            } else {
                $httpBody = $flow_cron_update_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Api-Key');
        if ($apiKey !== null) {
            $headers['Api-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadAttachments
     *
     * Upload Attachments
     *
     * @param  string $session_id session_id (required)
     * @param  \SplFileObject $file file (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadAttachments'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FlowHunt\Model\FlowSessionAttachmentResponse|\FlowHunt\Model\HTTPValidationError
     */
    public function uploadAttachments($session_id, $file, string $contentType = self::contentTypes['uploadAttachments'][0])
    {
        list($response) = $this->uploadAttachmentsWithHttpInfo($session_id, $file, $contentType);
        return $response;
    }

    /**
     * Operation uploadAttachmentsWithHttpInfo
     *
     * Upload Attachments
     *
     * @param  string $session_id (required)
     * @param  \SplFileObject $file (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadAttachments'] to see the possible values for this operation
     *
     * @throws \FlowHunt\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FlowHunt\Model\FlowSessionAttachmentResponse|\FlowHunt\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadAttachmentsWithHttpInfo($session_id, $file, string $contentType = self::contentTypes['uploadAttachments'][0])
    {
        $request = $this->uploadAttachmentsRequest($session_id, $file, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\FlowSessionAttachmentResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\FlowHunt\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\FlowHunt\Model\FlowSessionAttachmentResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\FlowSessionAttachmentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlowHunt\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation uploadAttachmentsAsync
     *
     * Upload Attachments
     *
     * @param  string $session_id (required)
     * @param  \SplFileObject $file (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadAttachments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadAttachmentsAsync($session_id, $file, string $contentType = self::contentTypes['uploadAttachments'][0])
    {
        return $this->uploadAttachmentsAsyncWithHttpInfo($session_id, $file, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadAttachmentsAsyncWithHttpInfo
     *
     * Upload Attachments
     *
     * @param  string $session_id (required)
     * @param  \SplFileObject $file (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadAttachments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadAttachmentsAsyncWithHttpInfo($session_id, $file, string $contentType = self::contentTypes['uploadAttachments'][0])
    {
        $returnType = '\FlowHunt\Model\FlowSessionAttachmentResponse';
        $request = $this->uploadAttachmentsRequest($session_id, $file, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadAttachments'
     *
     * @param  string $session_id (required)
     * @param  \SplFileObject $file (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadAttachments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function uploadAttachmentsRequest($session_id, $file, string $contentType = self::contentTypes['uploadAttachments'][0])
    {

        // verify the required parameter 'session_id' is set
        if ($session_id === null || (is_array($session_id) && count($session_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $session_id when calling uploadAttachments'
            );
        }

        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling uploadAttachments'
            );
        }


        $resourcePath = '/v2/flows/sessions/{session_id}/attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($session_id !== null) {
            $resourcePath = str_replace(
                '{' . 'session_id' . '}',
                ObjectSerializer::toPathValue($session_id),
                $resourcePath
            );
        }

        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file' => $file,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
